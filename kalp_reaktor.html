<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Dilara Interface Mobile V2 - Reactive</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --primary: #ff0055;
            --accent: #ff99cc;
            --bg: #020005; /* Noir l√©g√®rement teint√© */
        }

        body {
            margin: 0;
            background: radial-gradient(circle at center, #1a000a 0%, var(--bg) 80%);
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
        }

        #container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;
        }

        /* UI Overlay & Scanlines */
        .ui-layer { position: absolute; z-index: 10; width: 100%; pointer-events: none; }
        .scanlines {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(to bottom, transparent 0%, rgba(0,0,0,0.3) 50%, transparent 100%);
            background-size: 100% 3px;
            pointer-events: none; z-index: 5; opacity: 0.5;
        }
        .vignette {
             position: fixed; top: 0; left: 0; width: 100%; height: 100%;
             background: radial-gradient(circle, transparent 60%, black 150%);
             z-index: 6; pointer-events: none;
        }

        /* Header */
        #header {
            top: 25px; left: 0; text-align: center;
            color: var(--accent); text-shadow: 0 0 15px var(--primary);
        }
        #header h1 { font-size: 1.4rem; margin: 0; letter-spacing: 4px; font-weight: bold; }
        #header p { font-size: 0.7rem; margin: 5px 0 0 0; opacity: 0.9; letter-spacing: 2px; color: var(--primary); }

        /* Footer Status */
        #footer {
            bottom: 25px; left: 0; width: 100%; text-align: center;
        }
        .status-box {
            display: inline-flex; align-items: center;
            background: rgba(20, 0, 5, 0.6);
            border: 1px solid var(--primary);
            padding: 8px 15px; border-radius: 20px;
            box-shadow: 0 0 15px rgba(255, 0, 85, 0.3);
        }
        .status-text { color: white; font-size: 0.8rem; letter-spacing: 1px; }
        .status-dot {
            width: 8px; height: 8px; background: #ff3333;
            border-radius: 50%; margin-right: 8px;
            box-shadow: 0 0 8px #ff3333; transition: all 0.2s ease-in-out;
        }
        .status-dot.active { background: #00ffaa; box-shadow: 0 0 10px #00ffaa; }

        /* PIP */
        #pip-container {
            position: absolute; bottom: 25px; right: 20px;
            width: 70px; height: 90px;
            border: 2px solid var(--primary);
            border-radius: 8px; overflow: hidden; z-index: 20;
            background: rgba(0,0,0,0.8); box-shadow: 0 0 10px var(--primary);
        }
        #pip-canvas { width: 100%; height: 100%; transform: scaleX(-1); opacity: 0.8; }

        /* Start Screen */
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5,0,10,0.95); z-index: 100;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            text-align: center; color: white;
            transition: opacity 0.5s;
        }
        .glow-icon { font-size: 4rem; text-shadow: 0 0 20px var(--primary); animation: pulseIcon 2s infinite; }
        @keyframes pulseIcon { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); }}
        .start-btn {
            background: linear-gradient(45deg, var(--primary), #ff5500);
            border: none; color: white; padding: 15px 40px;
            font-size: 1.1rem; font-weight: bold; border-radius: 50px;
            margin-top: 30px; box-shadow: 0 0 25px var(--primary);
            cursor: pointer; transition: transform 0.2s;
        }
        .start-btn:active { transform: scale(0.95); }

        video { display: none; }
    </style>
</head>
<body>

    <div id="start-screen">
        <div class="glow-icon">üíñ</div>
        <h2 style="letter-spacing: 2px;">SYST√àME DILARA V2</h2>
        <p style="font-size: 0.9rem; color: #ccc; margin-top: -10px;">Haute R√©activit√© Activ√©e</p>
        <button class="start-btn" onclick="startApp()">ACTIVER L'INTERFACE</button>
    </div>

    <div id="container"></div>
    <div class="scanlines"></div>
    <div class="vignette"></div>

    <div id="header" class="ui-layer">
        <h1>PROJET DILARA</h1>
        <p>R√âACTEUR C≈íUR // HAUTE √âNERGIE</p>
    </div>

    <div id="footer" class="ui-layer">
        <div class="status-box">
            <span id="status-dot" class="status-dot"></span>
            <span id="status-text" class="status-text">EN ATTENTE DE SIGNAL...</span>
        </div>
    </div>

    <div id="pip-container"><canvas id="pip-canvas"></canvas></div>
    <video id="webcam-video" playsinline muted autoplay></video>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            particleCount: 7000, // L√©g√®re augmentation pour plus de densit√©
            // "Lerp" contr√¥le la vitesse de r√©action. 
            // Plus c'est haut (ex: 0.3), plus c'est r√©actif mais potentiellement nerveux.
            // Plus c'est bas (ex: 0.05), plus c'est doux mais lent.
            reactionSpeed: 0.25, // BEAUCOUP plus rapide qu'avant (√©tait 0.08)
        };

        let scene, camera, renderer, particles, geometry;
        const targetPositions = [];
        let expansionFactor = 1.0;
        let targetExpansion = 1.0; // Nouvelle variable pour lissage cible
        let pulseTime = 0;
        let isStarted = false;
        let handsDetected = 0;

        // --- THREE.JS (PARTIE GRAPHIQUE) ---
        function initThree() {
            const container = document.getElementById('container');
            
            scene = new THREE.Scene();
            // Brouillard color√© pour la profondeur
            scene.fog = new THREE.FogExp2(0x1a000a, 0.004);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // Position cam√©ra ajust√©e pour mobile
            camera.position.z = window.innerWidth < 600 ? 100 : 70;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            // Important pour le rendu des couleurs brillantes
            renderer.outputEncoding = THREE.sRGBEncoding; 
            container.appendChild(renderer.domElement);

            // --- NOUVELLE TEXTURE PLUS BELLE ---
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64; // R√©solution augment√©e
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32,32,0,32,32,32);
            // C≈ìur blanc chaud -> Rose vif -> Magenta profond -> Transparent
            grad.addColorStop(0, 'rgba(255, 255, 230, 1)');   // Centre chaud
            grad.addColorStop(0.2, 'rgba(255, 50, 120, 1)'); // Halo vif
            grad.addColorStop(0.5, 'rgba(180, 0, 60, 0.6)');  // Bord profond
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,64,64);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;

            // --- G√âOM√âTRIE & COULEURS ---
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.particleCount * 3);
            const colors = new Float32Array(CONFIG.particleCount * 3);
            const sizes = new Float32Array(CONFIG.particleCount);

            const baseColor = new THREE.Color();
            const tempColor = new THREE.Color();

            for(let i=0; i<CONFIG.particleCount; i++) {
                const ix = i*3;
                
                // Formule C≈ìur
                const t = Math.random() * Math.PI * 2;
                // Distribution plus concentr√©e vers le centre pour un effet "noyau"
                const density = 1 - Math.pow(Math.random(), 3); 
                
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random() - 0.5) * 12; // Un peu plus de volume 3D
                
                const scale = 1.7;
                targetPositions[ix] = x * scale * density;
                targetPositions[ix+1] = y * scale * density;
                targetPositions[ix+2] = z * scale * density;

                // Positions de d√©part (Explosion lointaine)
                positions[ix] = (Math.random()-0.5) * 500;
                positions[ix+1] = (Math.random()-0.5) * 500;
                positions[ix+2] = (Math.random()-0.5) * 500;

                // --- VARIATION DE COULEURS (Plus beau) ---
                // On part d'une base rose/rouge (hue ~340-355) et on varie l√©g√®rement
                baseColor.setHSL(0.95 + Math.random() * 0.05, 0.9, 0.5 + Math.random() * 0.3);
                // M√©lange avec un peu de violet pour la profondeur
                tempColor.setHex(0xff0055).lerp(new THREE.Color(0xaa00ff), Math.random() * 0.3);
                
                colors[ix] = baseColor.r * 0.7 + tempColor.r * 0.3;
                colors[ix+1] = baseColor.g * 0.7 + tempColor.g * 0.3;
                colors[ix+2] = baseColor.b * 0.7 + tempColor.b * 0.3;

                // --- VARIATION DE TAILLE ---
                sizes[i] = Math.random() * 2.0 + 0.5; // Taille entre 0.5 et 2.5
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            // --- MAT√âRIAU AM√âLIOR√â ---
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    pointTexture: { value: texture },
                    globalScale: { value: window.innerHeight / 2.0 } // Ajustement taille selon √©cran
                },
                vertexShader: `
                    attribute float size;
                    varying vec3 vColor;
                    uniform float globalScale;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                        // La taille d√©pend de la distance √† la cam√©ra pour un effet r√©aliste
                        gl_PointSize = size * ( globalScale / - mvPosition.z );
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D pointTexture;
                    varying vec3 vColor;
                    void main() {
                        gl_FragColor = vec4( vColor, 1.0 ) * texture2D( pointTexture, gl_PointCoord );
                    }
                `,
                blending: THREE.AdditiveBlending, // Superposition lumineuse
                depthTest: false,
                transparent: true,
                vertexColors: true // Active les couleurs par particule
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            animate();
        }

        // --- BOUCLE D'ANIMATION (LA CL√â DE LA R√âACTIVIT√â) ---
        function animate() {
            requestAnimationFrame(animate);

            if(particles) {
                // Rotation constante douce
                particles.rotation.y += 0.004;
                
                // --- C≈íUR DE LA R√âACTIVIT√â ---
                // On lisse la valeur cible d'expansion pour √©viter les tremblements trop violents,
                // mais avec un facteur rapide.
                expansionFactor += (targetExpansion - expansionFactor) * CONFIG.reactionSpeed;

                const positions = geometry.attributes.position.array;
                
                for(let i=0; i<CONFIG.particleCount; i++) {
                    const ix = i*3;
                    
                    // Calcul de la position cible avec l'expansion actuelle
                    const tx = targetPositions[ix] * expansionFactor;
                    const ty = targetPositions[ix+1] * expansionFactor;
                    const tz = targetPositions[ix+2] * expansionFactor;

                    // Interpolation tr√®s rapide vers la cible (C'est ici que √ßa devient r√©actif)
                    positions[ix] += (tx - positions[ix]) * CONFIG.reactionSpeed;
                    positions[ix+1] += (ty - positions[ix+1]) * CONFIG.reactionSpeed;
                    positions[ix+2] += (tz - positions[ix+2]) * CONFIG.reactionSpeed;
                }
                geometry.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }

        // --- VISION (MEDIAPIPE) ---
        function initCamera() {
            const videoElement = document.getElementById('webcam-video');
            const pipCanvas = document.getElementById('pip-canvas');
            const pipCtx = pipCanvas.getContext('2d');
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');

            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 0, // Lite pour rapidit√© mobile
                minDetectionConfidence: 0.6, // Un peu plus strict pour √©viter les faux positifs
                minTrackingConfidence: 0.6
            });

            hands.onResults((results) => {
                // Nettoyage PIP
                pipCtx.clearRect(0, 0, pipCanvas.width, pipCanvas.height);
                
                handsDetected = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;

                if (handsDetected === 2) {
                    // --- DEUX MAINS : CONTR√îLE TOTAL ---
                    statusDot.classList.add('active');
                    statusText.innerText = "CONNEXION: 2 MAINS (ACTIF)";
                    statusText.style.color = "#00ffaa";

                    // Calcul distance Index
                    const h1 = results.multiHandLandmarks[0][8];
                    const h2 = results.multiHandLandmarks[1][8];
                    const dist = Math.sqrt(Math.pow(h1.x - h2.x, 2) + Math.pow(h1.y - h2.y, 2));

                    // --- R√âGLAGE DE L'√âCHELLE (Plus dramatique) ---
                    // On mappe la distance (qui est petite, ~0.1 √† 0.6) vers une √©chelle plus grande.
                    // J'ai √©largi la plage pour que le c≈ìur devienne tr√®s petit ou tr√®s grand.
                    let scale = dist * 6.5; 
                    // Limites (Clamping)
                    if(scale < 0.6) scale = 0.6; // Minimum plus petit
                    if(scale > 4.5) scale = 4.5; // Maximum plus grand
                    
                    // C'est LA valeur cible que la boucle d'animation va essayer d'atteindre rapidement
                    targetExpansion = scale;

                    // Dessin PIP (vert)
                    drawPIP(results, pipCtx, '#00ffaa');

                } else if(handsDetected === 1) {
                    // --- UNE MAIN : Retour au calme ---
                    statusDot.classList.remove('active');
                    statusText.innerText = "CONNEXION: 1 MAIN (ATTENTE)";
                    statusText.style.color = "orange";
                    targetExpansion = 1.0; // Retour √† la taille normale
                    drawPIP(results, pipCtx, 'orange');

                } else {
                    // --- AUCUNE MAIN : Battement autonome ---
                    statusDot.classList.remove('active');
                    statusText.innerText = "RECHERCHE SIGNAL...";
                    statusText.style.color = "#ccc";

                    // Battement de c≈ìur "vivant" plus rapide
                    pulseTime += 0.12;
                    // Un battement plus marqu√© (style "boum-boum")
                    const pulse = Math.sin(pulseTime) > 0.7 ? 1.15 : (1.0 + Math.sin(pulseTime) * 0.05);
                    targetExpansion = pulse;
                }
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 320, height: 240, facingMode: 'user'
            });
            cameraUtils.start();
        }

        function drawPIP(results, ctx, color) {
            ctx.save();
            ctx.drawImage(results.image, 0, 0, ctx.canvas.width, ctx.canvas.height);
            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {color: color, lineWidth: 1});
                    drawLandmarks(ctx, landmarks, {color: color, lineWidth: 0.5, radius: 2});
                }
            }
            ctx.restore();
        }

        // --- START ---
        function startApp() {
            if(isStarted) return;
            isStarted = true;
            document.getElementById('start-screen').style.opacity = 0;
            setTimeout(() => { document.getElementById('start-screen').style.display = 'none'; }, 500);
            initThree();
            initCamera();
        }

        window.addEventListener('resize', () => {
            if(camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.position.z = window.innerWidth < 600 ? 100 : 70;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                // Met √† jour l'√©chelle globale pour le ShaderMaterial
                particles.material.uniforms.globalScale.value = window.innerHeight / 2.0;
            }
        });
    </script>
</body>
</html>
